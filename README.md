## Oystercard Challenge

### How to use

Open terminal


### How to run tests

### Steps

1. Create a Gemfile
2. Create RSpec conventional files
3. Review debugging basics
4. Create a basic Oyster card:

5. Add the balance
6. Enable top up functionality
7. Enforce maximum balance
8. Deduct the money
9. Add touch in/out functionality:

10. Add touch in/out support
11. Checking mininum balance on touch in
12. Charging for the journey
13. Record the journeys

14. Saving the entry station
15. Adding journey history
16. Creating the station class
17. Refactor to extract Journey class

18. Handling a journey without a touch out
19. Refactoring: get the code into shape

20. Extracting the journey log out of the Oystercard
21. Make fares depends on zones

22. Calculating the fare between zones

### Learning Objectives

- I write code that is easy to change: Writing easy to change software is highly prized amongst developers and employers. By developers because most of a developer's time is spent changing software. By employers because their teams can deliver value to customers faster.

- I can test-drive my code: Tested software is easier to change because you can tell when it's broken just by running a command, even the tricky edge cases.

- I can build with objects: Most code in the world is structured in small pieces called objects. This is done because it is easier to change than having everything in one place.
